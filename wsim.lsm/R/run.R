# Copyright (c) 2018 ISciences, LLC.
# All rights reserved.
#
# WSIM is licensed under the Apache License, Version 2.0 (the "License").
# You may not use this file except in compliance with the License. You may
# obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

#' Run a single iteration of the the model
#'
#' @param static a list containing static inputs to the model.
#'               The following variables are required:
#'               \describe{
#'               \item{elevation}{mean grid cell elevation in meters}
#'               \item{flow_directions}{flow direction grid described in \link{accumulate_flow}}
#'               \item{Wc}{soil moisture capacity in millimeters}
#'               }
#' @param state a \code{wsim.lsm.state} object containing an input state for the model.
#'              Described in \code{\link{make_state}}.
#' @param forcing a \code{wsim.lsm.forcing} object containing forcing for the model.
#'                Described in \code{\link{make_forcing}}.
#' @return a list containing model outputs and a state for the next time step:
#'              \describe{
#'              \item{obs}{a \code{wsim.lsm.results} object, as described in \code{\link{make_results}}}
#'              \item{next_state}{a \code{wsim.lsm.state} object containing the model state at the end of
#'                               the timestep. Described in \code{\link{make_state}}.}
#'              }
#' @useDynLib wsim.lsm, .registration=TRUE
#' @export
run <- function(static, state, forcing) {
  stopifnot(is.wsim.lsm.state(state))
  stopifnot(is.wsim.lsm.forcing(forcing))

  melt_month <- ifelse(
    forcing$T > -1,
    state$snowmelt_month + 1,
    0
  )

  nDays <- days_in_yyyymm(state$yearmon)

  # guard against NODATA values in state variables
  # this is necessary when reading IniData generated by older
  # versions of the LSM, which did not scrub NODATA values from outputs
  state$Snowpack[is.na(state$Snowpack)] <- 0.0
  state$Dr[is.na(state$Dr)] <- 0.0
  state$Ds[is.na(state$Ds)] <- 0.0
  state$Ws[is.na(state$Ws)] <- 0.0

  # estimate snow accumulation and snowmelt
  # use snow accumluation as a mask for snowmelt
  Sa <- snow_accum(forcing$Pr, forcing$T)
  Sm <- snow_melt(state$Snowpack, melt_month, forcing$T, static$elevation)

  P <- P_effective(forcing$Pr, Sa, Sm)

  area_m2 <- cell_areas_m2(state$extent, dim(forcing$T))

  daylength <- day_length_matrix(as.integer(substr(state$yearmon, 1, 4)),
                                as.integer(substr(state$yearmon, 5, 6)),
                                state$extent,
                                nrow(forcing$T),
                                ncol(forcing$T))
  E0 <- e_potential(daylength, forcing$T, nDays)

  hydro <- daily_hydro_loop(forcing$P, Sa, Sm, E0, state$Ws, static$Wc, nDays, forcing$pWetDays)
  dWdt <- hydro$dWdt
  E <- hydro$E
  R <- hydro$R
  Ws_ave <- hydro$Ws_ave

  detained <- calc_detained(R, forcing$Pr, P, Sm, state$Dr, state$Ds, static$elevation, melt_month);
  revised_runoff <- detained$Rp + detained$Rs

  next_state <- make_state(
    extent= state$extent,
    Snowpack= state$Snowpack + coalesce(Sa-Sm, 0.0),
    snowmelt_month= melt_month,
    Ws= state$Ws + coalesce(dWdt, 0.0),
    Dr= detained$Rp, # TODO resolve discrepancy with manual
    Ds= state$Ds + coalesce(detained$dDsdt, 0.0),
    yearmon= next_yyyymm(state$yearmon)
  )

  obs <- list(
    extent= state$extent,
    #dayLength= forcing$daylength,
    dWdt= dWdt,
    E= E,
    EmPET= E - E0,
    P_net= P,
    PET= E0,
    PETmE= E0 - E,
    Pr= forcing$Pr,
    RO_mm= revised_runoff,
    RO_m3= revised_runoff*area_m2/1000,
    Runoff_mm= R,
    Runoff_m3= R*area_m2/1000,
    Sa= Sa,
    Sm= ifelse(is.na(Sa), NA, Sm),
    Snowpack= state$Snowpack,
    T= forcing$T,
    Ws= Ws_ave
  )

  should_wrap_x <- all(state$extent[c(1, 2)] == c(-180, 180))
  should_wrap_y <- all(state$extent[c(3, 4)] == c(-90,  90))

  obs$Bt_RO <- accumulate_flow(static$flow_directions, obs$RO_m3, should_wrap_x, should_wrap_y)
  obs$Bt_Runoff <- accumulate_flow(static$flow_directions, obs$Runoff_m3, should_wrap_x, should_wrap_y)
  obs <- do.call(make_results, obs)

  return(list(
    obs=obs,
    next_state=next_state
  ))
}
