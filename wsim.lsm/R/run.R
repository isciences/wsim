# Copyright (c) 2018-2019 ISciences, LLC.
# All rights reserved.
#
# WSIM is licensed under the Apache License, Version 2.0 (the "License").
# You may not use this file except in compliance with the License. You may
# obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

#' Run a single iteration of the the model
#'
#' @param static a list containing static inputs to the model.
#'               The following variables are required:
#'               \describe{
#'               \item{elevation}{mean grid cell elevation in meters}
#'               \item{flow_directions}{flow direction grid described in \link{accumulate_flow}}
#'               \item{Wc}{soil moisture capacity in millimeters}
#'               }
#' @param state a \code{wsim.lsm.state} object containing an input state for the model.
#'              Described in \code{\link{make_state}}.
#' @param forcing a \code{wsim.lsm.forcing} object containing forcing for the model.
#'                Described in \code{\link{make_forcing}}.
#' @return a list containing model outputs and a state for the next time step:
#'              \describe{
#'              \item{obs}{a \code{wsim.lsm.results} object, as described in \code{\link{make_results}}}
#'              \item{next_state}{a \code{wsim.lsm.state} object containing the model state at the end of
#'                               the timestep. Described in \code{\link{make_state}}.}
#'              }
#' @useDynLib wsim.lsm, .registration=TRUE
#' @export
run <- function(static, state, forcing) {
  stopifnot(is.wsim.lsm.state(state))
  stopifnot(is.wsim.lsm.forcing(forcing))

  melt_month <- ifelse(
    forcing$T > -1,
    state$snowmelt_month + 1,
    0
  )

  nDays <- days_in_yyyymm(state$yearmon)
  grid_extent <- state$extent
  grid_dims <- dim(forcing$T)

  # guard against NODATA values in state variables
  # this is necessary when reading IniData generated by older
  # versions of the LSM, which did not scrub NODATA values from outputs
  state$Snowpack[is.na(state$Snowpack)] <- 0.0
  state$Dr[is.na(state$Dr)] <- 0.0
  state$Ds[is.na(state$Ds)] <- 0.0
  state$Ws[is.na(state$Ws)] <- 0.0

  # estimate snow accumulation and snowmelt
  # use snow accumluation as a mask for snowmelt
  Sa <- snow_accum(forcing$Pr, forcing$T)
  Sm <- snow_melt(state$Snowpack, melt_month, forcing$T, static$elevation)

  P <- P_effective(forcing$Pr, Sa, Sm)

  area_m2 <- cell_areas_m2(grid_extent, grid_dims)

  daylength <- day_length_matrix(as.integer(substr(state$yearmon, 1, 4)),
                                as.integer(substr(state$yearmon, 5, 6)),
                                state$extent,
                                nrow(forcing$T),
                                ncol(forcing$T))
  E0 <- e_potential(daylength, forcing$T, nDays)

  hydro <- daily_hydro_loop(forcing$P, Sa, Sm, E0, state$Ws, static$Wc, nDays, forcing$pWetDays)
  dWdt <- hydro$dWdt
  E <- hydro$E
  R <- hydro$R
  Ws_ave <- hydro$Ws_ave

  detained <- calc_detained(R, forcing$Pr, P, Sm, state$Dr, state$Ds, static$elevation, melt_month);
  revised_runoff <- detained$Rp + detained$Rs

  next_state <- make_state(
    extent= grid_extent,
    Snowpack= state$Snowpack + coalesce(Sa-Sm, 0.0),
    snowmelt_month= melt_month,
    Ws= state$Ws + coalesce(dWdt, 0.0),
    Dr= state$Dr + coalesce(detained$dDrdt, 0.0),
    Ds= state$Ds + coalesce(detained$dDsdt, 0.0),
    yearmon= next_yyyymm(state$yearmon)
  )

  obs <- list(
    extent= state$extent,
    dWdt= dWdt,
    E= E,
    EmPET= E - E0,
    P_net= P,
    PET= E0,
    PETmE= E0 - E,
    RO_mm= revised_runoff,
    RO_m3= revised_runoff*area_m2/1000,
    Runoff_mm= R,
    Runoff_m3= R*area_m2/1000,
    Sa= Sa,
    Sm= ifelse(is.na(Sa), NA, Sm),
    Ws= Ws_ave
  )

  should_wrap_x <- all(grid_extent[c(1, 2)] == c(-180, 180))
  should_wrap_y <- all(grid_extent[c(3, 4)] == c(-90,  90))

  obs$Bt_RO <- accumulate_flow(static$flow_directions, obs$RO_m3, should_wrap_x, should_wrap_y)
  obs$Bt_Runoff <- accumulate_flow(static$flow_directions, obs$Runoff_m3, should_wrap_x, should_wrap_y)

  # round the LSM results to avoid fitting distributions based entirely on noise
  # see https://gitlab.com/isciences/wsim/wsim/issues/70
  res_mm <- 0.1 # 0.1 mm resolution
  rounding_params <- list(
    digits_mm = digits_for_res(res_mm),
    digits_m3 = digits_for_res(res_mm_to_m3(res_mm, grid_extent, grid_dims))
  )

  obs <- do.call(make_results, c(obs, rounding_params))

  return(list(
    obs=obs,
    next_state=next_state
  ))
}

res_mm_to_m3 <- function(res_mm, extent, dim) {
  stopifnot(length(extent) == 4)
  stopifnot(length(dim) == 2)

  dlon <- (extent[2] - extent[1]) / dim[2]
  dlat <- (extent[4] - extent[3]) / dim[1]

  area_m2 <- cell_area_m2(-dlat/2, dlat/2, dlon)

  res_mm / 1000 * area_m2
}

digits_for_res <- function(res) {
  -floor(log10(res))
}
