% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rsapply.R
\name{rsapply}
\alias{rsapply}
\title{Apply a per-pixel function across a Raster*}
\usage{
rsapply(rast, fun, names = NULL, ...)
}
\arguments{
\item{rast}{A Raster*}

\item{fun}{a function to apply to each pixel of the raster.  The function
will be called with a vector representing the pixel values of
each raster in the stack, at a given (x,y).}

\item{names}{the names of the values returned by fun}

\item{...}{additional arguments to be passed to \code{fun}}
}
\value{
a new RasterLayer or RasterStack containing the values returned by
        \code{fun} at each pixel.
}
\description{
\code{rsapply} accepts either a single RasterLayer or a multi-layer RasterStack/RasterBrick.
At each pixel, \code{fun} will be called with a vector representing the values of
each layer at that pixel.  \code{fun} must return a vector of the same length
at every pixel.  If \code{fun} returns a vector with more than one element,
the result will be returned as a RasterStack; otherwise, it will be returned
as a RasterLayer.
}
\examples{
\dontrun{
#
# Fit per-pixel GEV distributions, given a RasterStack of
# observed values.
rsapply(observed, function(pvals) {
 lmr <- lmom::samlmu(pvals, nmom = 5)
 ret <- try(lmom::pelgev(lmr), silent=FALSE)
}, names=c('location', 'scale', 'shape'))}

\dontrun{
# Compute summary statistics over time-integrated observations
rsapply(precip_6mo, function(pvals) {
 c(min(pvals), mean(pvals), max(pvals))
}, names=c('min', 'ave', 'max'))
}
}
